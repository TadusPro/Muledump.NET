@page "/settings/accounts/edit/{Id:guid}"
@page "/settings/accounts/new"

@using MDTadusMod.Data

@inject Services.AccountService AccountSvc
@inject NavigationManager NavManager
@inject IJSRuntime JSRuntime
@implements IDisposable

<div class="account-edit-container">
    @if (editContext != null)
    {
        <EditForm EditContext="@editContext" OnValidSubmit="HandleValidSubmit">
            <DataAnnotationsValidator />
            @if (IsNew)
            {
                <div class="new-account-form">
                    <h1 class="text-center">Accounts Manager</h1>
                    <div class="horizontal info-bar">
                        <p class="text-muted">Add a new account</p>
                        <p class="text-danger">@emailErrorMessage</p>
                    </div>
                    <div class="horizontal">
                        <InputText id="email" @bind-Value="account.Email" class="form-control" placeholder="Email / steamworks" />
                        <InputText id="password" @bind-Value="account.Password" class="form-control" type="password" placeholder="password / secret" />
                    </div>
                    
                    <div class="horizontal">
                        <button type="submit" disabled="@isInvalid">Save</button>
                        <button type="button" class="close" @onclick="Cancel">Back</button>
                    </div>
                </div>
            }
            else
            {
                <div class="new-account-form">
                    <h1>Accounts Manager</h1>

                    <div class="horizontal info-bar">
                        @if (!string.IsNullOrEmpty(accountData?.Name))
                        {
                            <p class="text-info">ign: @accountData.Name</p>
                        }
                        <p class="text-danger">@emailErrorMessage</p>
                    </div>

                    <InputText id="email" @bind-Value="account.Email" class="form-control" placeholder="Email / steamworks" />

                    <InputText id="password" type="text" @bind-Value="account.Password" class="form-control" placeholder="New Password" />

                    <div class="horizontal">
                        <button type="submit" disabled="@(!editContext.IsModified() || isInvalid)">Update</button>
                        <button type="button" class="close" @onclick="Cancel">Cancel</button>
                    </div>

                    <div class="horizontal delete-row">
                        <button type="button" class="delete" @onclick="DeleteAccount">Delete Account</button>
                    </div>
                </div>
            }
        </EditForm>
    }
    else if (!IsNew)
    {
        <p>Loading account...</p>
    }
</div>

@code {
    [Parameter]
    public Guid Id { get; set; }

    private Account account;
    private AccountData accountData;
    private bool IsNew => Id == Guid.Empty;

    private EditContext editContext;
    private bool isInvalid = true;
    private ValidationMessageStore messageStore;
    private string emailErrorMessage = string.Empty;

    private async void HandleFieldChanged(object sender, FieldChangedEventArgs e)
    {
        messageStore.Clear(e.FieldIdentifier);
        emailErrorMessage = string.Empty;

        bool isModelValid = editContext.Validate();

        if (e.FieldIdentifier.FieldName == nameof(Account.Email))
        {
            var accounts = await AccountSvc.GetAccountsAsync();
            if (accounts.Any(a => a.Email.Equals(account.Email, StringComparison.OrdinalIgnoreCase) && a.Id != account.Id))
            {
                emailErrorMessage = "Email is already in use.";
                messageStore.Add(e.FieldIdentifier, emailErrorMessage);
                isModelValid = false;
            }
        }

        isInvalid = !isModelValid;
        StateHasChanged();
    }

    protected override async Task OnParametersSetAsync()
    {
        if (IsNew)
        {
            account = new Account();
        }
        else
        {
            var accounts = await AccountSvc.GetAccountsAsync();
            account = accounts.FirstOrDefault(a => a.Id == Id);

            if (account == null)
            {
                NavManager.NavigateTo("/settings/accounts");
                return;
            }

            accountData = await AccountSvc.GetAccountDataAsync(account.Id);
        }

        if (editContext == null || editContext.Model != account)
        {
            if (editContext != null)
            {
                editContext.OnFieldChanged -= HandleFieldChanged;
            }
            editContext = new(account);
            messageStore = new(editContext);
            editContext.OnFieldChanged += HandleFieldChanged;
        }
    }

    protected override void OnAfterRender(bool firstRender)
    {
        if (firstRender && editContext != null)
        {
            isInvalid = !editContext.Validate();
            StateHasChanged();
        }
    }

    private async Task HandleValidSubmit()
    {
        var accounts = await AccountSvc.GetAccountsAsync();
        if (IsNew)
        {
            account.Id = Guid.NewGuid();
            accounts.Add(account);
        }
        else
        {
            var existingAccount = accounts.FirstOrDefault(a => a.Id == account.Id);
            if (existingAccount != null)
            {
                existingAccount.Email = account.Email;
                existingAccount.Password = account.Password;
            }
        }

        await AccountSvc.SaveAccountsAsync(accounts);
        NavManager.NavigateTo("/settings/accounts");
    }

    private async Task DeleteAccount()
    {
        if (IsNew || account == null) return;

        var confirmed = await JSRuntime.InvokeAsync<bool>("confirm", $"Delete account '{account.Email}'?");
        if (!confirmed) return;

        await AccountSvc.DeleteAccountAsync(account.Id);
        NavManager.NavigateTo("/settings/accounts");
    }

    private void Cancel()
    {
        NavManager.NavigateTo("/settings/accounts");
    }

    public void Dispose()
    {
        if (editContext != null)
        {
            editContext.OnFieldChanged -= HandleFieldChanged;
        }
    }
}