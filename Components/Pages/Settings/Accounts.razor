@page "/settings/accounts"
@inject Services.AccountService AccountSvc
@inject Services.AccountImportService ImportSvc
@inject NavigationManager Navigation

<div class="main">
    @if (accounts == null)
    {
        <p><em>Loading...</em></p>
    }
    else
    {
        <div class="table-container">
            <h1>Accounts Manager</h1>
            <table>
                <tbody>
                    @foreach (var account in filteredAccounts)
                    {
                        <tr>
                            <td>
                                @{
                                    var index = accounts.IndexOf(account);
                                    var isFirst = index == 0;
                                    var isLast = index == accounts.Count - 1;
                                    var moveButtonClass = "move-buttons";
                                    if (isFirst) { moveButtonClass += " first-item"; }
                                    else if (isLast) { moveButtonClass += " last-item"; }
                                }
                                <div class="@moveButtonClass">
                                    @if (!isFirst)
                                    {
                                        <button class="btn-move" @onclick="() => MoveUp(account)">▲</button>
                                    }
                                    @if (!isLast)
                                    {
                                        <button class="btn-move" @onclick="() => MoveDown(account)">▼</button>
                                    }
                                </div>
                            </td>
                            <td>
                                <input value="@account.Email" readonly>
                            </td>
                            <td>
                                <input value="@account.Password" type="password" readonly>
                            </td>
                            <td>
                                <button class="editbtn" @onclick="() => EditAccount(account.Id)">≡</button>
                            </td>
                            <td>
                                <button class="deletebtn" @onclick="() => DeleteAccount(account.Id)">✖</button>
                            </td>
                        </tr>
                    }
                </tbody>
            </table>
            <div class="controls-container">
                <input class="search-bar" type="text" placeholder="Search..." @bind="searchTerm" @bind:event="oninput" />
                <button class="btn-import" @onclick="ImportAccounts">Import</button>
                <button class="btn-add-new" @onclick="AddNewAccount">Add New Account</button>
               
            </div>
            @if (showImportMessage && !string.IsNullOrWhiteSpace(importMessage))
            {
                <div class="import-result">
                    <span>
                        @importMessage
                    </span>
                </div>
            }
        </div>
    }
</div>

@code {
    private List<MDTadusMod.Data.Account> accounts;
    private string searchTerm = string.Empty;
    private string? importMessage;
    private bool showImportMessage;
    private CancellationTokenSource? _importMsgCts;

    private IEnumerable<MDTadusMod.Data.Account> filteredAccounts =>
        accounts?.Where(a => string.IsNullOrWhiteSpace(searchTerm) ||
                             a.Email.Contains(searchTerm, StringComparison.OrdinalIgnoreCase)) ?? Enumerable.Empty<MDTadusMod.Data.Account>();

    protected override async Task OnInitializedAsync()
    {
        accounts = await AccountSvc.GetAccountsAsync();
    }

    private void AddNewAccount()
    {
        Navigation.NavigateTo("/settings/accounts/new");
    }

    private void EditAccount(Guid accountId)
    {
        Navigation.NavigateTo($"/settings/accounts/edit/{accountId}");
    }

    private async Task DeleteAccount(Guid accountId)
    {
        var account = accounts.FirstOrDefault(a => a.Id == accountId);
        if (account != null)
        {
            await AccountSvc.DeleteAccountAsync(accountId);
            accounts.Remove(account);
            StateHasChanged();
        }
    }

    private async Task MoveUp(MDTadusMod.Data.Account account)
    {
        var index = accounts.IndexOf(account);
        if (index > 0)
        {
            (accounts[index], accounts[index - 1]) = (accounts[index - 1], accounts[index]);
            await AccountSvc.SaveAccountsAsync(accounts);
        }
    }

    private async Task MoveDown(MDTadusMod.Data.Account account)
    {
        var index = accounts.IndexOf(account);
        if (index > -1 && index < accounts.Count - 1)
        {
            (accounts[index], accounts[index + 1]) = (accounts[index + 1], accounts[index]);
            await AccountSvc.SaveAccountsAsync(accounts);
        }
    }

    private async Task ImportAccounts()
    {
        if (accounts is null)
            accounts = await AccountSvc.GetAccountsAsync();

        var result = await ImportSvc.ImportViaFilePickerAsync(accounts);
        var message = BuildImportMessage(result);
        await ShowImportMessage(message);
        StateHasChanged();
    }

    private static string BuildImportMessage(Services.AccountImportService.ImportResult result)
    {
        if (result.Total <= 0)
            return "Found no accounts.";

        var parts = new List<string>
        {
            $"Added {result.Added} {(result.Added == 1 ? "account" : "accounts")}"
        };

        if (result.Duplicates > 0)
            parts.Add($"skipped {result.Duplicates} {(result.Duplicates == 1 ? "account" : "accounts")}");

        if (result.Invalid > 0)
            parts.Add($"{result.Invalid} {(result.Invalid == 1 ? "line" : "lines")} invalid");

        return string.Join(", ", parts) + ".";
    }

    private async Task ShowImportMessage(string text)
    {
        _importMsgCts?.Cancel();
        _importMsgCts?.Dispose();
        _importMsgCts = new CancellationTokenSource();

        importMessage = text;
        showImportMessage = true;
        StateHasChanged();

        try
        {
            await Task.Delay(20000, _importMsgCts.Token);
            showImportMessage = false;
            StateHasChanged();
        }
        catch (TaskCanceledException)
        {
            // ignore
        }
    }
}