@using MDTadusMod.Data
@using MDTadusMod.Services
@using RotMGAssetExtractor.Model
@using System.Diagnostics
@inject SettingsService SettingsManager
@inject AssetService AssetService

<div class="char">
    @if (VO.CharDescription)
    {
        <div class="chdesc">
            <SpriteCard Type="@(Character.Skin != 0 ? Character.Skin : Character.ObjectType)" BackgroundOff="true"></SpriteCard>
            <div>
                <div style="padding-top: 3px;">
                    <span class="">@GetClassName(Character.ObjectType) @Character.Level, @(MaxedStats.Count)/8, #@Character.Id</span>
                </div>
                <div>
                    <img src="images/fame.png" alt="Fame" class="fame-icon" />
                    @FormatNumber(Character.CurrentFame) <span class="fame-state">Alive</span>
                    @if (!IsLoading)
                    {
                        <span> @FormatNumber(TotalFame) <span class="fame-state">Dead</span></span>
                    }
                </div>
            </div>
        </div>
    }

    @if (VO.Stats)
    {
        <table class="stats">
            <tbody>
                <tr>
                    <td class="sname">HP</td>
                    <td><strong class="stat @(MaxedStats.IsMaxed("MaxHitPoints") ? "maxed" : "")">@Character.MaxHitPoints</strong></td>
                    <td class="sname">MP</td>
                    <td><strong class="stat @(MaxedStats.IsMaxed("MaxMagicPoints") ? "maxed" : "")">@Character.MaxMagicPoints</strong></td>
                </tr>
                <tr>
                    <td class="sname">ATT</td>
                    <td><strong class="stat @(MaxedStats.IsMaxed("Attack") ? "maxed" : "")">@Character.Attack</strong></td>
                    <td class="sname">DEF</td>
                    <td><strong class="stat @(MaxedStats.IsMaxed("Defense") ? "maxed" : "")">@Character.Defense</strong></td>
                </tr>
                <tr>
                    <td class="sname">SPD</td>
                    <td><strong class="stat @(MaxedStats.IsMaxed("Speed") ? "maxed" : "")">@Character.Speed</strong></td>
                    <td class="sname">DEX</td>
                    <td><strong class="stat @(MaxedStats.IsMaxed("Dexterity") ? "maxed" : "")">@Character.Dexterity</strong></td>
                </tr>
                <tr>
                    <td class="sname">VIT</td>
                    <td><strong class="stat @(MaxedStats.IsMaxed("Vitality") ? "maxed" : "")">@Character.Vitality</strong></td>
                    <td class="sname">WIS</td>
                    <td><strong class="stat @(MaxedStats.IsMaxed("Wisdom") ? "maxed" : "")">@Character.Wisdom</strong></td>
                </tr>
            </tbody>
        </table>
    }

    @if (VO.Equipment)
    {
        <ItemContainer Items="EquipmentItems"
                       DisplayType="@GetDisplayType(nameof(VO.EquipmentDisplayType))"
                       NoPadding="true"
                       class="equipment" />
    }
    @if (VO.Inventory)
    {
        <ItemContainer Items="InventoryItems"
                       DisplayType="@GetDisplayType(nameof(VO.InventoryDisplayType))"
                       NoPadding="true"/>
    }

    @if (VO.AdditionalStats || VO.AdditionalBonuses || VO.AdditionalGoals)
    {
        <table class="pcstats">
            <tbody>
                @if (VO.AdditionalStats)
                {
                    @foreach (var stat in Character.ParsedPCStats.OrderBy(s => s.Key))
                    {
                        @if (!IsLoading && stat.Key == 20)
                        {
                            var timeSpan = TimeSpan.FromMinutes(stat.Value);
                            if (timeSpan.TotalDays >= 1)
                            {
                                <tr>
                                    <td>Days active</td>
                                    <td class="pcstat">@timeSpan.TotalDays.ToString("0.#")</td>
                                </tr>
                            }
                            else if (timeSpan.TotalHours >= 1)
                            {
                                <tr>
                                    <td>Hours active</td>
                                    <td class="pcstat">@timeSpan.TotalHours.ToString("0.#")</td>
                                </tr>
                            }
                            else
                            {
                                <tr>
                                    <td>Minutes active</td>
                                    <td class="pcstat">@timeSpan.Minutes</td>
                                </tr>
                            }
                        }
                        else
                        {
                            <tr>
                                <td>@GetPCStatName(stat.Key)</td>
                                <td class="pcstat">@FormatNumber(stat.Value)</td>
                            </tr>
                        }
                    }
                }
                @if ((VO.AdditionalBonuses) && CharacterFameBonuses.TryGetValue(Character.Id, out var bonuses) && bonuses.Any())
                {
                    string currentGroup = null;
                    var renderedCategories = new HashSet<string>();

                    for (int i = 0; i < bonuses.Count; i++)
                    {
                        var bonus = bonuses[i];

                        if (bonus.DisplayGroup != currentGroup)
                        {
                            currentGroup = bonus.DisplayGroup;
                            renderedCategories.Clear();
                        }

                        if (!string.IsNullOrEmpty(bonus.DisplayCategory))
                        {
                            if (renderedCategories.Add(bonus.DisplayCategory))
                            {
                                var categoryBonuses = bonuses
                                    .Where(b => b.DisplayGroup == currentGroup && b.DisplayCategory == bonus.DisplayCategory)
                                    .ToList();

                                <tr>
                                    <td>@bonus.DisplayCategory</td>
                                    <td class="bonus">+@categoryBonuses.Sum(b => CalculateBonusIncrement(b))</td>
                                </tr>
                            }
                        }
                        else if (VO.AdditionalBonuses)
                        {
                            <tr>
                                <td>@bonus.DisplayName</td>
                                <td class="bonus">+@CalculateBonusIncrement(bonus)</td>
                            </tr>
                        }
                    }
                }

                @if (VO.AdditionalGoals && UnachievedGoals?.Any() == true)
                {
                    foreach (var g in UnachievedGoals)
                    {
                        <tr>
                            <td colspan="2" class="goal-line">
                                <span class="goal-name">• @g.Name</span>
                                @if (!string.Equals(g.Group, "Stats Bonuses", StringComparison.OrdinalIgnoreCase) && !string.IsNullOrWhiteSpace(g.Requirement))
                                {
                                    <span class="goal-req">@g.Requirement</span>
                                }
                                <span class="goal-inc">+@g.Increment</span>
                            </td>
                        </tr>
                    }
                }
            </tbody>
        </table>
    }
</div>

@code {
    [Parameter, EditorRequired]
    public Character Character { get; set; }
    [Parameter, EditorRequired]
    public AccountViewOptions VO { get; set; }
    [Parameter, EditorRequired]
    public Dictionary<int, Dictionary<string, int>> MaxStatsPerClass { get; set; }
    [Parameter, EditorRequired]
    public Dictionary<int, string> ClassIdToNameMap { get; set; }
    [Parameter, EditorRequired]
    public Dictionary<int, string> PCStatIdToNameMap { get; set; }
    [Parameter, EditorRequired]
    public Dictionary<int, List<FameBonus>> CharacterFameBonuses { get; set; }

    // New: controlled by the parent to indicate loading state
    private bool IsLoading = true;

    private (int Count, Func<string, bool> IsMaxed) MaxedStats;
    private int TotalFame;
    private List<Item> EquipmentItems { get; set; } = new();
    private List<Item> InventoryItems { get; set; } = new();

    private Dictionary<int, string> _pcStatIdToNameLocal = new();

    private record GoalView(string Group, string Name, int Increment, string Requirement);
    private List<GoalView> UnachievedGoals = new();

    protected override async Task OnParametersSetAsync()
    {
        if (VO == null)
        {
            VO = SettingsManager.GlobalOptions;
        }

        MaxedStats = GetMaxedStats(Character);

        if (CharacterFameBonuses.TryGetValue(Character.Id, out var bonuses))
        {
            TotalFame = PCStatsParser.CalculateTotalFame(Character.CurrentFame, bonuses);
        }
        else
        {
            TotalFame = Character.CurrentFame;
        }

        var equipment = Character.EquipmentList ?? new List<Item>();
        EquipmentItems = equipment.Take(4).ToList();
        while (EquipmentItems.Count < 4)
        {
            EquipmentItems.Add(new Item { Id = -1 });
        }
        InventoryItems = equipment.Skip(4).ToList();

        UnachievedGoals.Clear();
        _pcStatIdToNameLocal = new Dictionary<int, string>();

        // Ensure AdditionalStats have readable names (fills blanks/missing)
        if (VO.AdditionalStats && Character?.ParsedPCStats != null && Character.ParsedPCStats.Count > 0)
        {
            try
            {
                var needed = Character.ParsedPCStats.Keys
                    .Where(id =>
                    {
                        if (_pcStatIdToNameLocal.ContainsKey(id)) return false;
                        if (PCStatIdToNameMap != null && PCStatIdToNameMap.TryGetValue(id, out var n))
                            return string.IsNullOrWhiteSpace(n);
                        return true;
                    })
                    .ToList();

                if (needed.Count > 0)
                {
                    var fetched = await Task.WhenAll(needed.Select(async id =>
                    {
                        var name = await SafeGetPCStatName(id);
                        return new { id, name };
                    }));

                    foreach (var f in fetched)
                    {
                        _pcStatIdToNameLocal[f.id] = f.name;
                        // Also patch the incoming map so subsequent renders reuse it
                        PCStatIdToNameMap[f.id] = f.name;
                    }
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"[CharacterCard] Failed to fetch AdditionalStats names: {ex.Message}");
            }
        }

        if (VO.AdditionalGoals)
        {
            try
            {
                var allBonuses = await AssetService.GetAllFameBonuses();
                var statNameToIdMap = await AssetService.GetPCStatNameToIdMap();
                var achieved = CharacterFameBonuses.TryGetValue(Character.Id, out var achievedList) ? achievedList : new List<FameBonus>();
                var achievedCodes = new HashSet<int>(achieved.Select(b => b.code));

                var groupOrder = new List<string> { "Stats Bonuses", "Enemy Bonuses", "Dungeon Bonuses" };

                var remaining = allBonuses
                    .Where(b => b.RelativeBonus > 0)
                    .Where(b => b.Condition != null && b.Condition.Length > 0 && !achievedCodes.Contains(b.code))
                    .OrderBy(b => {
                        var idx = groupOrder.IndexOf(b.DisplayGroup);
                        return idx == -1 ? int.MaxValue : idx;
                    })
                    .ThenBy(b => b.DisplayGroup)
                    .ThenBy(b => b.DisplayCategory)
                    .ThenBy(b => b.code)
                    .ToList();

                var neededIds = remaining
                    .SelectMany(b => b.Condition ?? Array.Empty<RotMGAssetExtractor.ModelHelpers.Condition>())
                    .Where(c => !string.IsNullOrWhiteSpace(c.stat))
                    .Select(c => statNameToIdMap.TryGetValue(c.stat, out var id) ? id : -1)
                    .Where(id => id >= 0)
                    .Distinct()
                    .Where(id => !_pcStatIdToNameLocal.ContainsKey(id))
                    .ToList();

                if (neededIds.Count > 0)
                {
                    var fetched = await Task.WhenAll(neededIds.Select(async id =>
                    {
                        var name = await SafeGetPCStatName(id);
                        return new { id, name };
                    }));
                    foreach (var f in fetched)
                        _pcStatIdToNameLocal[f.id] = f.name;
                }

                var bestByKey = new Dictionary<string, (FameBonus bonus, long distance, int increment)>();
                foreach (var bonus in remaining)
                {
                    var key = GetGoalKey(bonus, statNameToIdMap);
                    var dist = GetBonusDistanceToSatisfy(bonus, statNameToIdMap);
                    var inc = CalculateBonusIncrement(bonus);
                    if (dist < 0) continue;

                    if (!bestByKey.TryGetValue(key, out var current))
                        bestByKey[key] = (bonus, dist, inc);
                    else if (dist < current.distance || (dist == current.distance && inc > current.increment))
                        bestByKey[key] = (bonus, dist, inc);
                }

                var selected = bestByKey.Values
                    .Select(v => v.bonus)
                    .OrderBy(b => {
                        var idx = groupOrder.IndexOf(b.DisplayGroup);
                        return idx == -1 ? int.MaxValue : idx;
                    })
                    .ThenBy(b => b.DisplayGroup)
                    .ThenBy(b => b.DisplayCategory)
                    .ThenBy(b => b.code);

                foreach (var bonus in selected)
                {
                    var requirement = BuildRequirementText(bonus, statNameToIdMap);
                    var inc = CalculateBonusIncrement(bonus);
                    UnachievedGoals.Add(new GoalView(bonus.DisplayGroup ?? string.Empty, DecodeHtml(bonus.DisplayName ?? $"Bonus #{bonus.code}"), inc, requirement));
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"[CharacterCard] Failed to compute goals: {ex.Message}");
            }
        }
        IsLoading = false;
    }

    private async Task<string> SafeGetPCStatName(int id)
    {
        try
        {
            var name = await AssetService.GetPCStatName(id);
            return DecodeHtml(name);
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"[CharacterCard] GetPCStatName({id}) failed: {ex.Message}");
            return $"#{id}";
        }
    }

    private static string DecodeHtml(string s) =>
        System.Net.WebUtility.HtmlDecode(s ?? string.Empty);

    private string GetGoalKey(FameBonus bonus, Dictionary<string, int> statNameToIdMap)
    {
        // De-duplicate strictly by unique bonus code so multi-condition relative bonuses aren’t overridden.
        return $"code:{bonus.code}";
    }

    private long GetBonusDistanceToSatisfy(FameBonus bonus, Dictionary<string, int> statNameToIdMap)
    {
        if (bonus.Condition == null || bonus.Condition.Length == 0) return long.MaxValue / 2;

        long worst = 0;
        foreach (var cond in bonus.Condition)
        {
            long d = GetConditionDistance(cond, bonus.Repeatable, statNameToIdMap);
            if (d < 0) return -1;
            if (d > worst) worst = d;
        }
        return worst;
    }

    private long GetConditionDistance(RotMGAssetExtractor.ModelHelpers.Condition cond, bool repeatable, Dictionary<string, int> statNameToIdMap)
    {
        switch (cond.Value)
        {
            case "FirstCharacter":
                return Character.Id == 0 ? 0 : long.MaxValue / 2;
            case "MaxedStat":
                return MaxedStats.Count >= 8 ? 0 : long.MaxValue / 3;
            case "StatValue":
            case "gte":
            case "lte":
            case "eq":
            default:
            {
                if (string.IsNullOrWhiteSpace(cond.stat) || cond.threshold <= 0)
                    return long.MaxValue / 2;

                long current = GetStatValue(cond.stat, statNameToIdMap);

                if (repeatable && cond.threshold > 0)
                {
                    long mod = current % cond.threshold;
                    return mod == 0 ? cond.threshold : (cond.threshold - mod);
                }

                var cmp = string.IsNullOrWhiteSpace(cond.Value) ? "gte" : cond.Value.ToLowerInvariant();

                if (cond.threshold <= 1)
                    return current >= 1 ? 0 : 1;

                return cmp switch
                {
                    "lte" => current <= cond.threshold ? 0 : (current - cond.threshold),
                    "eq"  => Math.Abs(current - cond.threshold),
                    _     => current >= cond.threshold ? 0 : (cond.threshold - current),
                };
            }
        }
    }

    private string BuildRequirementText(FameBonus bonus, Dictionary<string, int> statNameToIdMap)
    {
        if (bonus.Condition == null || bonus.Condition.Length == 0)
            return string.Empty;

        var parts = new List<string>();

        foreach (var cond in bonus.Condition)
        {
            // Handle special non-stat conditions
            if (string.Equals(cond.Value, "FirstCharacter", StringComparison.OrdinalIgnoreCase))
            {
                if (Character.Id != 0)
                    parts.Add("First character");
                continue;
            }
            if (string.Equals(cond.Value, "MaxedStat", StringComparison.OrdinalIgnoreCase))
            {
                if (MaxedStats.Count < 8)
                    parts.Add("Max all stats (8/8)");
                continue;
            }

            // Repeatable stat conditions -> always show distance to next threshold
            if (bonus.Repeatable && cond.threshold > 0 && !string.IsNullOrWhiteSpace(cond.stat))
            {
                var statDisp = GetStatDisplayName(cond.stat, statNameToIdMap);
                long current = GetStatValue(cond.stat, statNameToIdMap);

                long toNext;
                if (current <= 0)
                {
                    toNext = cond.threshold;
                }
                else
                {
                    long mod = current % cond.threshold;
                    toNext = mod == 0 ? cond.threshold : (cond.threshold - mod);
                }

                parts.Add($"{FormatNumber(toNext)} more {statDisp} to next bonus (current: {FormatNumber(current)})");
                continue;
            }

            // Non-repeatable stat conditions -> only show if not satisfied
            if (string.IsNullOrWhiteSpace(cond.stat))
                continue;

            var statName = GetStatDisplayName(cond.stat, statNameToIdMap);
            long currentVal = GetStatValue(cond.stat, statNameToIdMap);
            int threshold = cond.threshold;
            var cmp = string.IsNullOrWhiteSpace(cond.Value) ? "gte" : cond.Value.ToLowerInvariant();

            bool satisfied;
            if (threshold <= 1)
            {
                satisfied = currentVal >= 1;
                if (!satisfied)
                    parts.Add(statName);
            }
            else
            {
                satisfied = cmp switch
                {
                    "lte" => currentVal <= threshold,
                    "eq"  => currentVal == threshold,
                    _     => currentVal >= threshold
                };

                if (!satisfied)
                {
                    string text = cmp switch
                    {
                        "lte" => $"{statName} ≤ {FormatNumber(threshold)}",
                        "eq"  => $"{statName} = {FormatNumber(threshold)}",
                        _     => $"{statName} ≥ {FormatNumber(threshold)}"
                    };
                    parts.Add(text);
                }
            }
        }

        var result = string.Join("; ", parts.Where(p => !string.IsNullOrWhiteSpace(p)));
        return DecodeHtml(result);
    }

    private bool TryGetParentStatName(int id, out string name)
    {
        name = null;
        try
        {
            if (PCStatIdToNameMap != null && PCStatIdToNameMap.TryGetValue(id, out var n))
            {
                name = DecodeHtml(n);
                return true;
            }
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"[CharacterCard] Parent map read failed for id {id}: {ex.Message}");
        }
        return false;
    }

    private string GetStatDisplayName(string statName, Dictionary<string, int> statNameToIdMap)
    {
        if (string.IsNullOrWhiteSpace(statName)) return "stat";
        if (statNameToIdMap.TryGetValue(statName, out var id))
        {
            if (_pcStatIdToNameLocal.TryGetValue(id, out var display))
                return DecodeHtml(display);

            if (TryGetParentStatName(id, out var parentName))
                return parentName;

            return $"#{id}";
        }
        return DecodeHtml(statName);
    }

    private long GetStatValue(string statName, Dictionary<string, int> statNameToIdMap)
    {
        if (string.IsNullOrWhiteSpace(statName)) return 0;
        if (statNameToIdMap.TryGetValue(statName, out var id))
        {
            return Character.ParsedPCStats.GetValueOrDefault(id, 0L);
        }
        return 0;
    }

    private (int Count, Func<string, bool> IsMaxed) GetMaxedStats(Character character)
    {
        if (character == null || MaxStatsPerClass == null || !MaxStatsPerClass.TryGetValue(character.ObjectType, out var maxStats))
        {
            return (0, s => false);
        }

        var maxed = new Dictionary<string, bool>();
        int maxedCount = 0;

        void CheckStat(string name, int value)
        {
            if (maxStats.TryGetValue(name, out var maxStatValue) && value >= maxStatValue)
            {
                maxed[name] = true;
                maxedCount++;
            }
            else
            {
                maxed[name] = false;
            }
        }

        CheckStat("MaxHitPoints", character.MaxHitPoints);
        CheckStat("MaxMagicPoints", character.MaxMagicPoints);
        CheckStat("Attack", character.Attack);
        CheckStat("Defense", character.Defense);
        CheckStat("Speed", character.Speed);
        CheckStat("Dexterity", character.Dexterity);
        CheckStat("Vitality", character.Vitality);
        CheckStat("Wisdom", character.Wisdom);

        return (maxedCount, s => maxed.GetValueOrDefault(s));
    }

    private int CalculateBonusIncrement(FameBonus bonus)
    {
        double increment = Math.Ceiling(Character.CurrentFame * (bonus.RelativeBonus / 100f));
        increment += bonus.AbsoluteBonus;
        return (int)increment;
    }

    private string GetClassName(int objectType)
    {
        return ClassIdToNameMap.GetValueOrDefault(objectType, "Unknown");
    }

    private string GetPCStatName(int statId)
    {
        if (_pcStatIdToNameLocal.TryGetValue(statId, out var local) && !string.IsNullOrWhiteSpace(local))
            return DecodeHtml(local);

        var name = PCStatIdToNameMap.GetValueOrDefault(statId, $"#{statId}");
        if (string.IsNullOrWhiteSpace(name))
            return $"#{statId}";
        return DecodeHtml(name);
    }

    private ContainerDisplayType GetDisplayType(string containerPropertyName)
    {
        if (!SettingsManager.GlobalSettings.ShowExtendedItemContainerDisplay)
            return ContainerDisplayType.chest;

        var property = typeof(AccountViewOptions).GetProperty(containerPropertyName);
        if (property != null && property.GetValue(VO) is ContainerDisplayType displayType)
        {
            return displayType;
        }

        return ContainerDisplayType.chest;
    }

    private (int id, int rarity) GetItemDetails(int itemId)
    {
        if (itemId == -1) return (-1, 0);

        var key = itemId.ToString();
        if (Character.UniqueItemData.TryGetValue(key, out var enchantList) && enchantList.Any())
        {
            var enchantData = enchantList.First();
            if (!string.IsNullOrEmpty(enchantData))
            {
                return (itemId, GetEnchantCount(enchantData));
            }
        }
        return (itemId, 0);
    }

    private int GetEnchantCount(string enchantData)
    {
        var enchants = new List<int>();
        if (string.IsNullOrEmpty(enchantData))
        {
            return 0;
        }

        byte[] data = Convert.FromBase64String(enchantData.Replace('-', '+').Replace('_', '/'));
        if (data.Length == 0)
        {
            return 0;
        }

        int index = 0;
        byte version = data[index];
        index++;

        const byte GradeId = 1;
        const byte EnchantmentSlotId = 2;
        const byte EnchantmentListId = 3;
        const byte RerollCountId = 4;
        const byte PowerupInfoId = 5;

        while (index < data.Length)
        {
            byte type = data[index];
            index++;

            switch (type)
            {
                case GradeId:
                    {
                        byte grade = data[index];
                        index++;
                        byte count = data[index];
                        index++;

                        index += count * sizeof(short);
                        break;
                    }
                case EnchantmentSlotId:
                    {
                        byte count = data[index];
                        index++;

                        for (int i = 0; i < count; i++)
                        {
                            short enchantmentId = BitConverter.ToInt16(data, index);
                            index += sizeof(short);
                            enchants.Add(enchantmentId);
                        }

                        break;
                    }
                case EnchantmentListId:
                    {
                        ushort count = BitConverter.ToUInt16(data, index);
                        index += sizeof(ushort);

                        index += count * sizeof(short);

                        break;
                    }
                case RerollCountId:
                    {
                        byte rerollCount = data[index];
                        index++;
                        break;
                    }
                case PowerupInfoId:
                    {
                        byte count = data[index];
                        index++;
                        for (int i = 0; i < count; i++)
                        {
                            byte id = data[index];
                            index++;
                            ushort value = BitConverter.ToUInt16(data, index);
                            index += sizeof(ushort);
                        }

                        break;
                    }
            }
        }

        return enchants.Count(id => id != -3);
    }

    private string FormatNumber(long num)
    {
        if (num >= 1000000000)
            return (num / 1000000000D).ToString("0") + "B";
        if (num >= 1000000)
            return (num / 1000000D).ToString("0") + "M";
        if (num >= 1000)
            return (num / 1000D).ToString("0") + "K";
        return num.ToString("N0");
    }
}